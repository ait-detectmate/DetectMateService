{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DetectMate Service Framework Welcome to the DetectMate Service Framework documentation. DetectMate is a flexible, component-based framework for building distributed detection and processing services. The Detectmate Framework consists of the Detectmate Service and the Detectmate Library . The DetectMate Service is a very generic Microservice that handles the input, forwards it to the DetectMate Library, which processes the data, and finally sends the results back to the output interfaces. It uses NNG's messaging architecture to process data in real-time. Key features Modular design : easily extensible with custom processors and components. Resilient networking : built on top of pynng (NNG) for high-performance messaging. Configurable : fully configurable via YAML files or environment variables. Service management : built-in CLI for starting, stopping, and monitoring the service. Scalable : run multiple independent service instances. Getting started Check out the Installation guide to set up the service, and then proceed to Configuration and Usage to learn how to run it. For a list of imports from the DetectMateLinbrary in the Service and their usage Library Imports . For library developers implementing custom components, see the Library Interface Contract . Contribution We're happily taking patches and other contributions. Please see the following links for how to get started: Git Workflow Development Details License DetectMateService is Free Open Source Software and uses the EUPL-1.2 License","title":"Home"},{"location":"#detectmate-service-framework","text":"Welcome to the DetectMate Service Framework documentation. DetectMate is a flexible, component-based framework for building distributed detection and processing services. The Detectmate Framework consists of the Detectmate Service and the Detectmate Library . The DetectMate Service is a very generic Microservice that handles the input, forwards it to the DetectMate Library, which processes the data, and finally sends the results back to the output interfaces. It uses NNG's messaging architecture to process data in real-time.","title":"DetectMate Service Framework"},{"location":"#key-features","text":"Modular design : easily extensible with custom processors and components. Resilient networking : built on top of pynng (NNG) for high-performance messaging. Configurable : fully configurable via YAML files or environment variables. Service management : built-in CLI for starting, stopping, and monitoring the service. Scalable : run multiple independent service instances.","title":"Key features"},{"location":"#getting-started","text":"Check out the Installation guide to set up the service, and then proceed to Configuration and Usage to learn how to run it. For a list of imports from the DetectMateLinbrary in the Service and their usage Library Imports . For library developers implementing custom components, see the Library Interface Contract .","title":"Getting started"},{"location":"#contribution","text":"We're happily taking patches and other contributions. Please see the following links for how to get started: Git Workflow Development Details","title":"Contribution"},{"location":"#license","text":"DetectMateService is Free Open Source Software and uses the EUPL-1.2 License","title":"License"},{"location":"configuration/","text":"Configuration DetectMateService can be configured using a YAML settings file or environment variables. Environment variables take precedence over the YAML file. Service settings These settings control the service infrastructure. Setting Env Variable Default Description component_name DETECTMATE_COMPONENT_NAME None A human-readable name for the service instance. component_id DETECTMATE_COMPONENT_ID None (computed) Unique identifier for the component; computed automatically if not provided. component_type DETECTMATE_COMPONENT_TYPE core Python import path for the component class (e.g., detectors.MyDetector ). component_config_class DETECTMATE_COMPONENT_CONFIG_CLASS None Python import path of the configuration class used by the component (e.g., detectors.MyDetectorConfig ). log_level DETECTMATE_LOG_LEVEL INFO Logging level ( DEBUG , INFO , WARNING , ERROR ). log_dir DETECTMATE_LOG_DIR ./logs Directory for log files. log_to_console DETECTMATE_LOG_TO_CONSOLE true Whether logs are written to stdout/stderr. log_to_file DETECTMATE_LOG_TO_FILE true Whether logs are written to files in log_dir . http_host DETECTMATE_HTTP_HOST 127.0.0.1 Host address for the HTTP server. http_port DETECTMATE_HTTP_PORT 8000 Port for the HTTP server. manager_recv_timeout DETECTMATE_MANAGER_RECV_TIMEOUT 100 Receive timeout (ms) for the manager command channel. manager_thread_join_timeout DETECTMATE_MANAGER_THREAD_JOIN_TIMEOUT 1.0 Timeout (s) when waiting for the manager thread to stop. engine_addr DETECTMATE_ENGINE_ADDR ipc:///tmp/detectmate.engine.ipc Address for data processing (PAIR0/1). engine_autostart DETECTMATE_ENGINE_AUTOSTART true Whether the engine channel is started automatically. engine_recv_timeout DETECTMATE_ENGINE_RECV_TIMEOUT 100 Receive timeout (ms) for the engine channel. out_addr DETECTMATE_OUT_ADDR [] List of output addresses (strongly typed NNG URLs). out_dial_timeout DETECTMATE_OUT_DIAL_TIMEOUT 1000 Timeout (ms) for connecting to output addresses. YAML files You can provide a YAML file containing the service settings. Below is an example settings.yaml : component_name: \"my-detector\" log_level: \"DEBUG\" log_dir: \"./logs\" # Manager Interface http_host: 127.0.0.1 http_port: 8000 # Engine Interface (Data Channel) engine_addr: \"ipc:///tmp/detectmate.engine.ipc\" engine_autostart: true # Output Destinations (where processed data is sent) out_addr: - \"tcp://127.0.0.1:5000\" - \"ipc:///tmp/output.ipc\" out_dial_timeout: 1000 Environment variables Environment variables override values in the YAML file. They are prefixed with DETECTMATE_ . Example: export DETECTMATE_LOG_LEVEL=DEBUG export DETECTMATE_COMPONENT_NAME=worker-1 detectmate start Component configuration In addition to the service settings (which configure the runner ), you can also pass a separate configuration file for the specific component logic (e.g., detector parameters) using the --config flag in the CLI. This file is specific to the implementation of the component you are running. Component configuration controls the specific logic of the detector or parser. To support dynamic library loading, this file uses a nested structure. The configuration must be namespaced by the component category (detectors or parsers) and the specific class name to allow the library to correctly route parameters. Example detector_config.yaml detectors: # Category Level NewValueDetector: # Class Name Level auto_config: false method_type: new_value_detector params: # Implementation Specific Level log_variables: - id: test template: dummy_template variables: - name: var1 pos: 0 params: threshold: 0.0 You can read more about Components in the Using a Library Component section. HTTP Admin Interface The service provides a REST API for runtime management and monitoring. Core Endpoints Method Endpoint Description GET /admin/status Returns the health, running state, and current effective configurations. POST /admin/start Starts the data processing engine thread. POST /admin/stop Stops the data processing engine thread. POST /admin/reconfigure Updates component parameters dynamically. POST /admin/shutdown Gracefully terminates the entire service process.","title":"Configuration"},{"location":"configuration/#configuration","text":"DetectMateService can be configured using a YAML settings file or environment variables. Environment variables take precedence over the YAML file.","title":"Configuration"},{"location":"configuration/#service-settings","text":"These settings control the service infrastructure. Setting Env Variable Default Description component_name DETECTMATE_COMPONENT_NAME None A human-readable name for the service instance. component_id DETECTMATE_COMPONENT_ID None (computed) Unique identifier for the component; computed automatically if not provided. component_type DETECTMATE_COMPONENT_TYPE core Python import path for the component class (e.g., detectors.MyDetector ). component_config_class DETECTMATE_COMPONENT_CONFIG_CLASS None Python import path of the configuration class used by the component (e.g., detectors.MyDetectorConfig ). log_level DETECTMATE_LOG_LEVEL INFO Logging level ( DEBUG , INFO , WARNING , ERROR ). log_dir DETECTMATE_LOG_DIR ./logs Directory for log files. log_to_console DETECTMATE_LOG_TO_CONSOLE true Whether logs are written to stdout/stderr. log_to_file DETECTMATE_LOG_TO_FILE true Whether logs are written to files in log_dir . http_host DETECTMATE_HTTP_HOST 127.0.0.1 Host address for the HTTP server. http_port DETECTMATE_HTTP_PORT 8000 Port for the HTTP server. manager_recv_timeout DETECTMATE_MANAGER_RECV_TIMEOUT 100 Receive timeout (ms) for the manager command channel. manager_thread_join_timeout DETECTMATE_MANAGER_THREAD_JOIN_TIMEOUT 1.0 Timeout (s) when waiting for the manager thread to stop. engine_addr DETECTMATE_ENGINE_ADDR ipc:///tmp/detectmate.engine.ipc Address for data processing (PAIR0/1). engine_autostart DETECTMATE_ENGINE_AUTOSTART true Whether the engine channel is started automatically. engine_recv_timeout DETECTMATE_ENGINE_RECV_TIMEOUT 100 Receive timeout (ms) for the engine channel. out_addr DETECTMATE_OUT_ADDR [] List of output addresses (strongly typed NNG URLs). out_dial_timeout DETECTMATE_OUT_DIAL_TIMEOUT 1000 Timeout (ms) for connecting to output addresses.","title":"Service settings"},{"location":"configuration/#yaml-files","text":"You can provide a YAML file containing the service settings. Below is an example settings.yaml : component_name: \"my-detector\" log_level: \"DEBUG\" log_dir: \"./logs\" # Manager Interface http_host: 127.0.0.1 http_port: 8000 # Engine Interface (Data Channel) engine_addr: \"ipc:///tmp/detectmate.engine.ipc\" engine_autostart: true # Output Destinations (where processed data is sent) out_addr: - \"tcp://127.0.0.1:5000\" - \"ipc:///tmp/output.ipc\" out_dial_timeout: 1000","title":"YAML files"},{"location":"configuration/#environment-variables","text":"Environment variables override values in the YAML file. They are prefixed with DETECTMATE_ . Example: export DETECTMATE_LOG_LEVEL=DEBUG export DETECTMATE_COMPONENT_NAME=worker-1 detectmate start","title":"Environment variables"},{"location":"configuration/#component-configuration","text":"In addition to the service settings (which configure the runner ), you can also pass a separate configuration file for the specific component logic (e.g., detector parameters) using the --config flag in the CLI. This file is specific to the implementation of the component you are running. Component configuration controls the specific logic of the detector or parser. To support dynamic library loading, this file uses a nested structure. The configuration must be namespaced by the component category (detectors or parsers) and the specific class name to allow the library to correctly route parameters. Example detector_config.yaml detectors: # Category Level NewValueDetector: # Class Name Level auto_config: false method_type: new_value_detector params: # Implementation Specific Level log_variables: - id: test template: dummy_template variables: - name: var1 pos: 0 params: threshold: 0.0 You can read more about Components in the Using a Library Component section.","title":"Component configuration"},{"location":"configuration/#http-admin-interface","text":"The service provides a REST API for runtime management and monitoring.","title":"HTTP Admin Interface"},{"location":"configuration/#core-endpoints","text":"Method Endpoint Description GET /admin/status Returns the health, running state, and current effective configurations. POST /admin/start Starts the data processing engine thread. POST /admin/stop Stops the data processing engine thread. POST /admin/reconfigure Updates component parameters dynamically. POST /admin/shutdown Gracefully terminates the entire service process.","title":"Core Endpoints"},{"location":"contribution/","text":"Contributing We're happily taking patches and other contributions. Below is a summary of the processes we follow for any contribution. Bug reports and enhancement requests Bug reports and enhancement requests are an important part of making DetectMateService more stable and are curated through Github issues. Before reporting an issue, check our backlog of open issues to see if anybody else has already reported it. If that is the case, you might be able to give additional information on that issue. Bug reports are very helpful to us in improving the software, and therefore, they are very welcome. It is very important to give us at least the following information in a bug report: Description of the bug. Describe the problem clearly. Steps to reproduce. With the following configuration, go to.., click.., see error Expected behavoir. What should happen? Environment. What was the environment for the test(version, browser, etc..) Please don't include any private/sensitive information in your issue! For reporting security-related issues, see SECURITY.md Working on the codebase To contribute to this project, you must fork the project and create a pull request to the upstream repository. The following figure shows the workflow: 1. Fork Go to https://github.com/ait-detectmate/DetectMateService.git and click on fork. Please note that you must login first to GitHub. 2. Clone After forking the repository into your own workspace, clone the development branch of that repository. git clone -b development git@github.com:YOURUSERNAME/DetectMateService.git 3. Create a feature branch Every single workpackage should be developed in it's own feature-branch. Use a name that describes the feature: cd DetectMateService git checkout -b feature-some_important_work 4. Develop your feature and improvements in the feature-branch Please make sure that you commit only improvements that are related to the workpage you created the feature-branch for. See the section Development for detailed information about how to develope code for DetectMateService . DetectMateService uses prek to ensure code quality. Make sure that you use it properly 5. Fetch and merge from the upstream If your work on this feature-branch is done, make sure that you are in sync with the branch of the upstream: git remote add upstream git@github.com:ait-detectmate/DetectMateService.git git pull upstream development If any conflicts occur, fix them and add them using git add and continue with the merge or fast-forward. Additional infos: https://www.atlassian.com/git/tutorials/merging-vs-rebasing https://www.atlassian.com/git/tutorials/merging-vs-rebasing#the-golden-rule-of-rebasing https://dev.to/toogoodyshoes/mastering-rebasing-and-fast-forwarding-in-git-2j19 6. Push the changes to your GitHub-repository Before we can push our changes, we have to make sure that we don't have unnecessary commits. First checkout our commits: git log After that we can squash the last n commits together: git rebase -i HEAD~n Finally you can push the changes to YOUR github-repository: git push Additional documentation: https://www.atlassian.com/git/tutorials/merging-vs-rebasing 7. Submit your pull-request Use the GitHub-Webinterface to create a pull-request. Make sure that the target-repository is ait-detectmate/DetectMateService . If your pull-request was accepted and merged into the development branch continue with \"8. Update your local development branch\". If it wasn't accepted, read the comments and fix the problems. Before pushing the changes make sure that you squashed them with your last commit: git rebase -i HEAD~2 Delete your local feature-branch after the pull-request was merged into the development branch. 8. Update your local main branch Update your local development branch: git fetch upstream development git checkout -b development git rebase upstream/development Additional infos: https://www.atlassian.com/git/tutorials/merging-vs-rebasing 9. Update your main branch in your github-repository Please make sure that you updated your local development branch as described in section 8. above. After that push the changes to your github-repository to keep it up2date: git push","title":"Contribution"},{"location":"contribution/#contributing","text":"We're happily taking patches and other contributions. Below is a summary of the processes we follow for any contribution.","title":"Contributing"},{"location":"contribution/#bug-reports-and-enhancement-requests","text":"Bug reports and enhancement requests are an important part of making DetectMateService more stable and are curated through Github issues. Before reporting an issue, check our backlog of open issues to see if anybody else has already reported it. If that is the case, you might be able to give additional information on that issue. Bug reports are very helpful to us in improving the software, and therefore, they are very welcome. It is very important to give us at least the following information in a bug report: Description of the bug. Describe the problem clearly. Steps to reproduce. With the following configuration, go to.., click.., see error Expected behavoir. What should happen? Environment. What was the environment for the test(version, browser, etc..) Please don't include any private/sensitive information in your issue! For reporting security-related issues, see SECURITY.md","title":"Bug reports and enhancement requests"},{"location":"contribution/#working-on-the-codebase","text":"To contribute to this project, you must fork the project and create a pull request to the upstream repository. The following figure shows the workflow:","title":"Working on the codebase"},{"location":"contribution/#1-fork","text":"Go to https://github.com/ait-detectmate/DetectMateService.git and click on fork. Please note that you must login first to GitHub.","title":"1. Fork"},{"location":"contribution/#2-clone","text":"After forking the repository into your own workspace, clone the development branch of that repository. git clone -b development git@github.com:YOURUSERNAME/DetectMateService.git","title":"2. Clone"},{"location":"contribution/#3-create-a-feature-branch","text":"Every single workpackage should be developed in it's own feature-branch. Use a name that describes the feature: cd DetectMateService git checkout -b feature-some_important_work","title":"3. Create a feature branch"},{"location":"contribution/#4-develop-your-feature-and-improvements-in-the-feature-branch","text":"Please make sure that you commit only improvements that are related to the workpage you created the feature-branch for. See the section Development for detailed information about how to develope code for DetectMateService . DetectMateService uses prek to ensure code quality. Make sure that you use it properly","title":"4. Develop your feature and improvements in the feature-branch"},{"location":"contribution/#5-fetch-and-merge-from-the-upstream","text":"If your work on this feature-branch is done, make sure that you are in sync with the branch of the upstream: git remote add upstream git@github.com:ait-detectmate/DetectMateService.git git pull upstream development If any conflicts occur, fix them and add them using git add and continue with the merge or fast-forward. Additional infos: https://www.atlassian.com/git/tutorials/merging-vs-rebasing https://www.atlassian.com/git/tutorials/merging-vs-rebasing#the-golden-rule-of-rebasing https://dev.to/toogoodyshoes/mastering-rebasing-and-fast-forwarding-in-git-2j19","title":"5. Fetch and merge from the upstream"},{"location":"contribution/#6-push-the-changes-to-your-github-repository","text":"Before we can push our changes, we have to make sure that we don't have unnecessary commits. First checkout our commits: git log After that we can squash the last n commits together: git rebase -i HEAD~n Finally you can push the changes to YOUR github-repository: git push Additional documentation: https://www.atlassian.com/git/tutorials/merging-vs-rebasing","title":"6. Push the changes to your GitHub-repository"},{"location":"contribution/#7-submit-your-pull-request","text":"Use the GitHub-Webinterface to create a pull-request. Make sure that the target-repository is ait-detectmate/DetectMateService . If your pull-request was accepted and merged into the development branch continue with \"8. Update your local development branch\". If it wasn't accepted, read the comments and fix the problems. Before pushing the changes make sure that you squashed them with your last commit: git rebase -i HEAD~2 Delete your local feature-branch after the pull-request was merged into the development branch.","title":"7. Submit your pull-request"},{"location":"contribution/#8-update-your-local-main-branch","text":"Update your local development branch: git fetch upstream development git checkout -b development git rebase upstream/development Additional infos: https://www.atlassian.com/git/tutorials/merging-vs-rebasing","title":"8. Update your local main branch"},{"location":"contribution/#9-update-your-main-branch-in-your-github-repository","text":"Please make sure that you updated your local development branch as described in section 8. above. After that push the changes to your github-repository to keep it up2date: git push","title":"9. Update your main branch in your github-repository"},{"location":"development/","text":"Development This section describes how to setup a development environment and how to contribute to DetectMateService . Note Read the Contribution Guide to follow and understand the development workflow. Setup a development environment For development we recommend using uv . You can install all optional dependencies: uv sync --dev Please note that this step is not necessary. uv run --dev will automatically download all dependencies. Use prek to run code checks Every code contributer must use prek to run basic checks at commit time. prek is configured via the existing .pre-commit-config.yaml and can be installed as part of the dev extras. To ensure pre-commit hooks run before each commit, run: uv run prek install To run the checks manually, you can execute: uv run prek run -a Add tests and run pytest In oder to run the tests run the following command: uv run --dev pytest","title":"Overview"},{"location":"development/#development","text":"This section describes how to setup a development environment and how to contribute to DetectMateService . Note Read the Contribution Guide to follow and understand the development workflow.","title":"Development"},{"location":"development/#setup-a-development-environment","text":"For development we recommend using uv . You can install all optional dependencies: uv sync --dev Please note that this step is not necessary. uv run --dev will automatically download all dependencies.","title":"Setup a development environment"},{"location":"development/#use-prek-to-run-code-checks","text":"Every code contributer must use prek to run basic checks at commit time. prek is configured via the existing .pre-commit-config.yaml and can be installed as part of the dev extras. To ensure pre-commit hooks run before each commit, run: uv run prek install To run the checks manually, you can execute: uv run prek run -a","title":"Use prek to run code checks"},{"location":"development/#add-tests-and-run-pytest","text":"In oder to run the tests run the following command: uv run --dev pytest","title":"Add tests and run pytest"},{"location":"installation/","text":"Installation First, clone DetectMateService and navigate into the repository: git clone https://github.com/ait-detectmate/DetectMateService.git cd DetectMateService Setup with uv (recommended) We recommend using uv to manage the environment and dependencies. 1. Download the dependencies uv sync Alternative setup with pip If you prefer plain pip , you can set things up like this instead: # Create a virtual environment python -m venv .venv # Activate it source .venv/bin/activate # Install the project in editable mode with dev dependencies pip install .","title":"Installation"},{"location":"installation/#installation","text":"First, clone DetectMateService and navigate into the repository: git clone https://github.com/ait-detectmate/DetectMateService.git cd DetectMateService","title":"Installation"},{"location":"installation/#setup-with-uv-recommended","text":"We recommend using uv to manage the environment and dependencies.","title":"Setup with uv (recommended)"},{"location":"installation/#1-download-the-dependencies","text":"uv sync","title":"1. Download the dependencies"},{"location":"installation/#alternative-setup-with-pip","text":"If you prefer plain pip , you can set things up like this instead: # Create a virtual environment python -m venv .venv # Activate it source .venv/bin/activate # Install the project in editable mode with dev dependencies pip install .","title":"Alternative setup with pip"},{"location":"interfaces/","text":"Library Interface Contract This document describes the interface contract between DetectMateService and DetectMateLibrary. If you're implementing custom components in the library, your classes must adhere to these interfaces. CoreComponent Interface All processing components (readers, parsers, detectors) must inherit from CoreComponent : from detectmatelibrary.common.core import CoreComponent class MyComponent(CoreComponent): def __init__(self, config=None): \"\"\"Initialize the component. Args: config: Optional configuration dictionary or CoreConfig instance. May be None if no configuration is provided. \"\"\" super().__init__(config) # Your initialization here def process(self, data: bytes) -> bytes | None: \"\"\"Process incoming data. Args: data: Raw bytes received from the upstream component. Returns: bytes: Processed data to forward to downstream components. None: Skip forwarding (filter out this message). \"\"\" # Your processing logic here return processed_data Key Requirements Constructor : Must accept an optional config parameter (can be dict or CoreConfig instance) process() method : Must accept bytes and return bytes | None Return behavior : Return bytes to forward output to downstream components Return None to skip/filter the message (no output sent) CoreConfig Interface Configuration classes must inherit from CoreConfig , which extends Pydantic's BaseModel : from detectmatelibrary.common.core import CoreConfig class MyComponentConfig(CoreConfig): \"\"\"Configuration for MyComponent.\"\"\" threshold: float = 0.5 window_size: int = 10 enabled: bool = True Key Requirements Pydantic BaseModel : Must support model_validate() and model_dump() methods Type hints : All fields should have type annotations Defaults : Provide sensible defaults where appropriate Configuration Flow Service loads config from YAML file via ConfigManager Schema identification: The service calls get_config_schema() , which uses ConfigClassLoader to dynamically import and verify the configuration class. Validation: It ensures the config class is a subclass of CoreConfig . Component Instantiation: The service identifies the component_type from settings. It uses ComponentLoader to dynamically load the class. Validation: It ensures the component class is an instance of CoreComponent Config from ConfigManager is passed to component constructor The Library processes and validates the configuration internally Validation: The library checks if auto_config is enabled. If disabled and no params exist, it raises an AutoConfigError. Type Checking: It ensures the method_type matches the expected component type (via check_type ). Formatting ( apply_format ): It iterates through the params dictionary. For every parameter, it applies a specific format. Keyword Cleaning: If a parameter key starts with all_ , the library processes it and strips the prefix (e.g., all_threshold becomes threshold). Flattening: The library flattens the structure by updating the top-level config dictionary with the contents of params and then deleting the now-redundant params key. Processor Adaptation: The service wraps the CoreComponent in a LibraryComponentProcessor (an adapter) to make it compatible with the Engine loop. At runtime, reconfigure command can update configs dynamically Component Loading Components are loaded dynamically by ComponentLoader . Specify components using a dot-separated path: Path Format module.ClassName Examples: - detectors.RandomDetector - parsers.JsonParser - readers.FileReader Resolution Order DetectMateLibrary-relative (tried first): detectmatelibrary.{path} detectors.RandomDetector \u2192 detectmatelibrary.detectors.RandomDetector Absolute import (fallback): {path} as-is mypackage.detectors.CustomDetector \u2192 mypackage.detectors.CustomDetector This allows you to use library components with short paths while still supporting custom components from external packages. Service Settings In your service settings YAML, specify: component_type: detectors.MyDetector # Component class path component_config_class: detectors.MyDetectorConfig # Config class path config_file: detector-config.yaml # Path to component config Data Flow Schemas Components in the processing pipeline use protobuf schemas for structured data exchange: Stage Input Output Schema Reader Raw source (file, network, etc.) LogSchema Parser LogSchema bytes ParserSchema Detector ParserSchema bytes DetectorSchema Each component receives serialized protobuf bytes, deserializes them, processes the data, and serializes the output for the next stage. Complete Example Here's a minimal detector component implementation: 1. Config Class ( detectors/random_detector.py ) from detectmatelibrary.common._config._formats import LogVariables, AllLogVariables from detectmatelibrary.common.detector import CoreDetector, CoreDetectorConfig from detectmatelibrary.utils.data_buffer import BufferMode import detectmatelibrary.schemas as schemas from typing_extensions import override from typing import List, Any import numpy as np class RandomDetectorConfig(CoreDetectorConfig): method_type: str = \"random_detector\" log_variables: LogVariables | AllLogVariables | dict[str, Any] = {} class RandomDetector(CoreDetector): \"\"\"Detects anomalies randomly in logs, completely independent of the input data.\"\"\" def __init__( self, name: str = \"RandomDetector\", config: RandomDetectorConfig = RandomDetectorConfig() ) -> None: if isinstance(config, dict): config = RandomDetectorConfig.from_dict(config, name) super().__init__(name=name, buffer_mode=BufferMode.NO_BUF, config=config) self.config: RandomDetectorConfig @override def train(self, input_: List[schemas.ParserSchema] | schemas.ParserSchema) -> None: # type: ignore \"\"\"Training is not applicable for RandomDetector.\"\"\" return @override def detect( self, input_: schemas.ParserSchema, output_: schemas.DetectorSchema # type: ignore ) -> bool: \"\"\"Detect anomalies randomly in the input data.\"\"\" overall_score = 0.0 alerts = {} relevant_log_fields = self.config.log_variables[input_[\"EventID\"]].get_all() # type: ignore for log_variable in relevant_log_fields.values(): score = 0.0 random = np.random.rand() if random > log_variable.params[\"threshold\"]: score = 1.0 alerts.update({log_variable.name: str(score)}) # type: ignore overall_score += score if overall_score > 0: output_[\"score\"] = overall_score output_[\"alertsObtain\"].update(alerts) return True return False 2. Service Settings ( settings.yaml ) component_name: random-detector component_type: detectors.random_detector.RandomDetector component_config_class: detectors.random_detector.RandomDetectorConfig config_file: random-config.yaml log_level: INFO http_host: 127.0.0.1 http_port: 8000 engine_addr: ipc:///tmp/threshold.engine.ipc 3. Component Config ( random-config.yaml ) Component configuration uses a nested structure: detectors: RandomDetector: method_type: random_detector auto_config: False params: log_variables: - id: test event: 1 template: dummy_template variables: - pos: 0 name: var1 params: threshold: 0. header_variables: - pos: level params: {} This hierarchical format allows the library to correctly route parameters based on category and class name. 4. Run the Service detectmate --settings settings.yaml --configs random-config.yaml Validation The service validates components at load time: Component class : Must be an instance of CoreComponent (in ComponentLoader ) Config class : Must be a subclass of CoreConfig (in ConfigClassLoader ) If validation fails, the service raises an error.","title":"Interfaces"},{"location":"interfaces/#library-interface-contract","text":"This document describes the interface contract between DetectMateService and DetectMateLibrary. If you're implementing custom components in the library, your classes must adhere to these interfaces.","title":"Library Interface Contract"},{"location":"interfaces/#corecomponent-interface","text":"All processing components (readers, parsers, detectors) must inherit from CoreComponent : from detectmatelibrary.common.core import CoreComponent class MyComponent(CoreComponent): def __init__(self, config=None): \"\"\"Initialize the component. Args: config: Optional configuration dictionary or CoreConfig instance. May be None if no configuration is provided. \"\"\" super().__init__(config) # Your initialization here def process(self, data: bytes) -> bytes | None: \"\"\"Process incoming data. Args: data: Raw bytes received from the upstream component. Returns: bytes: Processed data to forward to downstream components. None: Skip forwarding (filter out this message). \"\"\" # Your processing logic here return processed_data","title":"CoreComponent Interface"},{"location":"interfaces/#key-requirements","text":"Constructor : Must accept an optional config parameter (can be dict or CoreConfig instance) process() method : Must accept bytes and return bytes | None Return behavior : Return bytes to forward output to downstream components Return None to skip/filter the message (no output sent)","title":"Key Requirements"},{"location":"interfaces/#coreconfig-interface","text":"Configuration classes must inherit from CoreConfig , which extends Pydantic's BaseModel : from detectmatelibrary.common.core import CoreConfig class MyComponentConfig(CoreConfig): \"\"\"Configuration for MyComponent.\"\"\" threshold: float = 0.5 window_size: int = 10 enabled: bool = True","title":"CoreConfig Interface"},{"location":"interfaces/#key-requirements_1","text":"Pydantic BaseModel : Must support model_validate() and model_dump() methods Type hints : All fields should have type annotations Defaults : Provide sensible defaults where appropriate","title":"Key Requirements"},{"location":"interfaces/#configuration-flow","text":"Service loads config from YAML file via ConfigManager Schema identification: The service calls get_config_schema() , which uses ConfigClassLoader to dynamically import and verify the configuration class. Validation: It ensures the config class is a subclass of CoreConfig . Component Instantiation: The service identifies the component_type from settings. It uses ComponentLoader to dynamically load the class. Validation: It ensures the component class is an instance of CoreComponent Config from ConfigManager is passed to component constructor The Library processes and validates the configuration internally Validation: The library checks if auto_config is enabled. If disabled and no params exist, it raises an AutoConfigError. Type Checking: It ensures the method_type matches the expected component type (via check_type ). Formatting ( apply_format ): It iterates through the params dictionary. For every parameter, it applies a specific format. Keyword Cleaning: If a parameter key starts with all_ , the library processes it and strips the prefix (e.g., all_threshold becomes threshold). Flattening: The library flattens the structure by updating the top-level config dictionary with the contents of params and then deleting the now-redundant params key. Processor Adaptation: The service wraps the CoreComponent in a LibraryComponentProcessor (an adapter) to make it compatible with the Engine loop. At runtime, reconfigure command can update configs dynamically","title":"Configuration Flow"},{"location":"interfaces/#component-loading","text":"Components are loaded dynamically by ComponentLoader . Specify components using a dot-separated path:","title":"Component Loading"},{"location":"interfaces/#path-format","text":"module.ClassName Examples: - detectors.RandomDetector - parsers.JsonParser - readers.FileReader","title":"Path Format"},{"location":"interfaces/#resolution-order","text":"DetectMateLibrary-relative (tried first): detectmatelibrary.{path} detectors.RandomDetector \u2192 detectmatelibrary.detectors.RandomDetector Absolute import (fallback): {path} as-is mypackage.detectors.CustomDetector \u2192 mypackage.detectors.CustomDetector This allows you to use library components with short paths while still supporting custom components from external packages.","title":"Resolution Order"},{"location":"interfaces/#service-settings","text":"In your service settings YAML, specify: component_type: detectors.MyDetector # Component class path component_config_class: detectors.MyDetectorConfig # Config class path config_file: detector-config.yaml # Path to component config","title":"Service Settings"},{"location":"interfaces/#data-flow-schemas","text":"Components in the processing pipeline use protobuf schemas for structured data exchange: Stage Input Output Schema Reader Raw source (file, network, etc.) LogSchema Parser LogSchema bytes ParserSchema Detector ParserSchema bytes DetectorSchema Each component receives serialized protobuf bytes, deserializes them, processes the data, and serializes the output for the next stage.","title":"Data Flow Schemas"},{"location":"interfaces/#complete-example","text":"Here's a minimal detector component implementation:","title":"Complete Example"},{"location":"interfaces/#1-config-class-detectorsrandom_detectorpy","text":"from detectmatelibrary.common._config._formats import LogVariables, AllLogVariables from detectmatelibrary.common.detector import CoreDetector, CoreDetectorConfig from detectmatelibrary.utils.data_buffer import BufferMode import detectmatelibrary.schemas as schemas from typing_extensions import override from typing import List, Any import numpy as np class RandomDetectorConfig(CoreDetectorConfig): method_type: str = \"random_detector\" log_variables: LogVariables | AllLogVariables | dict[str, Any] = {} class RandomDetector(CoreDetector): \"\"\"Detects anomalies randomly in logs, completely independent of the input data.\"\"\" def __init__( self, name: str = \"RandomDetector\", config: RandomDetectorConfig = RandomDetectorConfig() ) -> None: if isinstance(config, dict): config = RandomDetectorConfig.from_dict(config, name) super().__init__(name=name, buffer_mode=BufferMode.NO_BUF, config=config) self.config: RandomDetectorConfig @override def train(self, input_: List[schemas.ParserSchema] | schemas.ParserSchema) -> None: # type: ignore \"\"\"Training is not applicable for RandomDetector.\"\"\" return @override def detect( self, input_: schemas.ParserSchema, output_: schemas.DetectorSchema # type: ignore ) -> bool: \"\"\"Detect anomalies randomly in the input data.\"\"\" overall_score = 0.0 alerts = {} relevant_log_fields = self.config.log_variables[input_[\"EventID\"]].get_all() # type: ignore for log_variable in relevant_log_fields.values(): score = 0.0 random = np.random.rand() if random > log_variable.params[\"threshold\"]: score = 1.0 alerts.update({log_variable.name: str(score)}) # type: ignore overall_score += score if overall_score > 0: output_[\"score\"] = overall_score output_[\"alertsObtain\"].update(alerts) return True return False","title":"1. Config Class (detectors/random_detector.py)"},{"location":"interfaces/#2-service-settings-settingsyaml","text":"component_name: random-detector component_type: detectors.random_detector.RandomDetector component_config_class: detectors.random_detector.RandomDetectorConfig config_file: random-config.yaml log_level: INFO http_host: 127.0.0.1 http_port: 8000 engine_addr: ipc:///tmp/threshold.engine.ipc","title":"2. Service Settings (settings.yaml)"},{"location":"interfaces/#3-component-config-random-configyaml","text":"Component configuration uses a nested structure: detectors: RandomDetector: method_type: random_detector auto_config: False params: log_variables: - id: test event: 1 template: dummy_template variables: - pos: 0 name: var1 params: threshold: 0. header_variables: - pos: level params: {} This hierarchical format allows the library to correctly route parameters based on category and class name.","title":"3. Component Config (random-config.yaml)"},{"location":"interfaces/#4-run-the-service","text":"detectmate --settings settings.yaml --configs random-config.yaml","title":"4. Run the Service"},{"location":"interfaces/#validation","text":"The service validates components at load time: Component class : Must be an instance of CoreComponent (in ComponentLoader ) Config class : Must be a subclass of CoreConfig (in ConfigClassLoader ) If validation fails, the service raises an error.","title":"Validation"},{"location":"library-imports/","text":"Library Import Points This document provides an overview of where DetectMateService imports from DetectMateLibrary and how those imports are used. For implementation details of the library classes, refer to the DetectMateLibrary documentation. Summary of Imports Import Source Module Used In Purpose CoreComponent detectmatelibrary.common.core core.py , component_loader.py Base class for all processing components CoreConfig detectmatelibrary.common.core core.py , config_loader.py , config_manager.py Base class for configuration schemas LogSchema detectmatelibrary.schemas Integration tests Reader output format ParserSchema detectmatelibrary.schemas Integration tests Parser output format DetectorSchema detectmatelibrary.schemas Integration tests Detector output format CoreComponent Import location: src/service/core.py , src/service/features/component_loader.py from detectmatelibrary.common.core import CoreComponent Usage Points 1. Component Loading ( component_loader.py ) The ComponentLoader dynamically imports component classes and validates they inherit from CoreComponent : Instantiation : Components are instantiated with an optional config parameter Type checking : isinstance(instance, CoreComponent) validates the loaded class instance = component_class(config=config) if not isinstance(instance, CoreComponent): raise TypeError(...) 2. Processor Adapter ( core.py ) The LibraryComponentProcessor wraps a CoreComponent to use it as the service's message processor: process() invocation : The service calls component.process(raw_message) for each incoming message Return handling : bytes output is forwarded; None skips the message result = self.component.process(raw_message) What the Service Expects from CoreComponent Constructor accepts optional config parameter process(data: bytes) -> bytes | None method handles message processing See Library Interface Contract for the full interface specification CoreConfig Import location: src/service/core.py , src/service/features/config_loader.py , src/service/features/config_manager.py from detectmatelibrary.common.core import CoreConfig Usage Points 1. Config Class Loading ( config_loader.py ) The ConfigClassLoader dynamically imports config classes and validates they inherit from CoreConfig : Subclass checking : issubclass(config_class, CoreConfig) validates the class hierarchy if not issubclass(config_class, CoreConfig): raise TypeError(...) 2. Schema for ConfigManager ( config_manager.py ) The ConfigManager uses CoreConfig subclasses as Pydantic schemas for validation: Default creation : self.schema() creates default config instances Validation : self.schema.model_validate(data) validates incoming config data Serialization : model_dump() converts config to dict for YAML storage # Validation self._configs = self.schema.model_validate(new_configs) # Serialization data = self._configs.model_dump() 3. Service Initialization ( core.py ) The Service.get_config_schema() method returns the appropriate CoreConfig subclass for the component. What the Service Expects from CoreConfig Must be a Pydantic BaseModel subclass Must support model_validate(data) for validation Must support model_dump() for serialization See Library Interface Contract for the full interface specification Protobuf Schemas Import location: Integration tests only ( tests/library_integration/ ) from detectmatelibrary.schemas import LogSchema, ParserSchema, DetectorSchema Usage Points The schemas are used in integration tests to verify correct data flow between pipeline stages: LogSchema : Serialized output from Reader components ParserSchema : Serialized output from Parser components DetectorSchema : Serialized output from Detector components Data Flow Reader Parser Detector | | | v v v LogSchema bytes ---> ParserSchema bytes ---> DetectorSchema bytes What the Service Expects from Schemas Protobuf message classes with SerializeToString() and ParseFromString() methods Consistent structure for pipeline interoperability Import Resolution The service uses a two-step import resolution for library components: DetectMateLibrary-relative (tried first): Prepends detectmatelibrary. to the path Absolute import (fallback): Uses the path as-is This allows short paths like detectors.RandomDetector to resolve to detectmatelibrary.detectors.RandomDetector , while still supporting custom components from external packages. File Reference Service File Library Imports Purpose src/service/core.py CoreComponent , CoreConfig Service base class, processor adapter src/service/features/component_loader.py CoreComponent Dynamic component loading src/service/features/config_loader.py CoreConfig Dynamic config class loading src/service/features/config_manager.py CoreConfig Configuration validation and persistence","title":"Library Imports"},{"location":"library-imports/#library-import-points","text":"This document provides an overview of where DetectMateService imports from DetectMateLibrary and how those imports are used. For implementation details of the library classes, refer to the DetectMateLibrary documentation.","title":"Library Import Points"},{"location":"library-imports/#summary-of-imports","text":"Import Source Module Used In Purpose CoreComponent detectmatelibrary.common.core core.py , component_loader.py Base class for all processing components CoreConfig detectmatelibrary.common.core core.py , config_loader.py , config_manager.py Base class for configuration schemas LogSchema detectmatelibrary.schemas Integration tests Reader output format ParserSchema detectmatelibrary.schemas Integration tests Parser output format DetectorSchema detectmatelibrary.schemas Integration tests Detector output format","title":"Summary of Imports"},{"location":"library-imports/#corecomponent","text":"Import location: src/service/core.py , src/service/features/component_loader.py from detectmatelibrary.common.core import CoreComponent","title":"CoreComponent"},{"location":"library-imports/#usage-points","text":"","title":"Usage Points"},{"location":"library-imports/#1-component-loading-component_loaderpy","text":"The ComponentLoader dynamically imports component classes and validates they inherit from CoreComponent : Instantiation : Components are instantiated with an optional config parameter Type checking : isinstance(instance, CoreComponent) validates the loaded class instance = component_class(config=config) if not isinstance(instance, CoreComponent): raise TypeError(...)","title":"1. Component Loading (component_loader.py)"},{"location":"library-imports/#2-processor-adapter-corepy","text":"The LibraryComponentProcessor wraps a CoreComponent to use it as the service's message processor: process() invocation : The service calls component.process(raw_message) for each incoming message Return handling : bytes output is forwarded; None skips the message result = self.component.process(raw_message)","title":"2. Processor Adapter (core.py)"},{"location":"library-imports/#what-the-service-expects-from-corecomponent","text":"Constructor accepts optional config parameter process(data: bytes) -> bytes | None method handles message processing See Library Interface Contract for the full interface specification","title":"What the Service Expects from CoreComponent"},{"location":"library-imports/#coreconfig","text":"Import location: src/service/core.py , src/service/features/config_loader.py , src/service/features/config_manager.py from detectmatelibrary.common.core import CoreConfig","title":"CoreConfig"},{"location":"library-imports/#usage-points_1","text":"","title":"Usage Points"},{"location":"library-imports/#1-config-class-loading-config_loaderpy","text":"The ConfigClassLoader dynamically imports config classes and validates they inherit from CoreConfig : Subclass checking : issubclass(config_class, CoreConfig) validates the class hierarchy if not issubclass(config_class, CoreConfig): raise TypeError(...)","title":"1. Config Class Loading (config_loader.py)"},{"location":"library-imports/#2-schema-for-configmanager-config_managerpy","text":"The ConfigManager uses CoreConfig subclasses as Pydantic schemas for validation: Default creation : self.schema() creates default config instances Validation : self.schema.model_validate(data) validates incoming config data Serialization : model_dump() converts config to dict for YAML storage # Validation self._configs = self.schema.model_validate(new_configs) # Serialization data = self._configs.model_dump()","title":"2. Schema for ConfigManager (config_manager.py)"},{"location":"library-imports/#3-service-initialization-corepy","text":"The Service.get_config_schema() method returns the appropriate CoreConfig subclass for the component.","title":"3. Service Initialization (core.py)"},{"location":"library-imports/#what-the-service-expects-from-coreconfig","text":"Must be a Pydantic BaseModel subclass Must support model_validate(data) for validation Must support model_dump() for serialization See Library Interface Contract for the full interface specification","title":"What the Service Expects from CoreConfig"},{"location":"library-imports/#protobuf-schemas","text":"Import location: Integration tests only ( tests/library_integration/ ) from detectmatelibrary.schemas import LogSchema, ParserSchema, DetectorSchema","title":"Protobuf Schemas"},{"location":"library-imports/#usage-points_2","text":"The schemas are used in integration tests to verify correct data flow between pipeline stages: LogSchema : Serialized output from Reader components ParserSchema : Serialized output from Parser components DetectorSchema : Serialized output from Detector components","title":"Usage Points"},{"location":"library-imports/#data-flow","text":"Reader Parser Detector | | | v v v LogSchema bytes ---> ParserSchema bytes ---> DetectorSchema bytes","title":"Data Flow"},{"location":"library-imports/#what-the-service-expects-from-schemas","text":"Protobuf message classes with SerializeToString() and ParseFromString() methods Consistent structure for pipeline interoperability","title":"What the Service Expects from Schemas"},{"location":"library-imports/#import-resolution","text":"The service uses a two-step import resolution for library components: DetectMateLibrary-relative (tried first): Prepends detectmatelibrary. to the path Absolute import (fallback): Uses the path as-is This allows short paths like detectors.RandomDetector to resolve to detectmatelibrary.detectors.RandomDetector , while still supporting custom components from external packages.","title":"Import Resolution"},{"location":"library-imports/#file-reference","text":"Service File Library Imports Purpose src/service/core.py CoreComponent , CoreConfig Service base class, processor adapter src/service/features/component_loader.py CoreComponent Dynamic component loading src/service/features/config_loader.py CoreConfig Dynamic config class loading src/service/features/config_manager.py CoreConfig Configuration validation and persistence","title":"File Reference"},{"location":"library/","text":"Note : For implementing custom library components, see the Library Interface Contract . Using a Library Component The Service can be run as any component imported from the DetectMateLibrary . For this, ensure that the library is installed in the same activated virtual environment, where the service is installed. 1. Update settings Modify settings.yaml to use a library component: component_name: new_value_detector component_type: detectors.NewValueDetector component_config_class: detectors.NewValueDetectorConfig config_file: detector-config.yaml log_level: INFO manager_addr: ipc:///tmp/detectmate.cmd.ipc engine_addr: ipc:///tmp/detectmate.engine.ipc 2. Create component configuration Create detector-config.yaml : detectors: # Category Level NewValueDetector: # Class Name Level auto_config: false method_type: new_value_detector params: # Implementation Specific Level log_variables: - id: test template: dummy_template variables: - name: var1 pos: 0 params: threshold: 0.0 3. Start with configuration detectmate --settings settings.yaml --config detector-config.yaml 4. Reconfigure at runtime Create new-config.yaml : detectors: NewValueDetector: auto_config: false method_type: new_value_detector params: log_variables: - id: test template: dummy_template variables: - name: var1 pos: 0 params: threshold: 0.8 The service supports dynamic reconfiguration with two modes: 1. In-memory update (default) Changes are applied to the running service but not saved to disk. The changes will be lost when the service restarts. detectmate-client --url 127.0.0.1:8000 reconfigure path/to/new-config.yaml 2. Persistent update (with --persist flag) Changes are applied to the running service AND saved to the original parameter file. The changes persist across service restarts. detectmate-client --url 127.0.0.1:8000 reconfigure path/to/new-config.yaml --persist Note: The --persist flag will overwrite the original parameter file specified in your service configuration with the new values.","title":"Using a Library Component"},{"location":"library/#using-a-library-component","text":"The Service can be run as any component imported from the DetectMateLibrary . For this, ensure that the library is installed in the same activated virtual environment, where the service is installed.","title":"Using a Library Component"},{"location":"library/#1-update-settings","text":"Modify settings.yaml to use a library component: component_name: new_value_detector component_type: detectors.NewValueDetector component_config_class: detectors.NewValueDetectorConfig config_file: detector-config.yaml log_level: INFO manager_addr: ipc:///tmp/detectmate.cmd.ipc engine_addr: ipc:///tmp/detectmate.engine.ipc","title":"1. Update settings"},{"location":"library/#2-create-component-configuration","text":"Create detector-config.yaml : detectors: # Category Level NewValueDetector: # Class Name Level auto_config: false method_type: new_value_detector params: # Implementation Specific Level log_variables: - id: test template: dummy_template variables: - name: var1 pos: 0 params: threshold: 0.0","title":"2. Create component configuration"},{"location":"library/#3-start-with-configuration","text":"detectmate --settings settings.yaml --config detector-config.yaml","title":"3. Start with configuration"},{"location":"library/#4-reconfigure-at-runtime","text":"Create new-config.yaml : detectors: NewValueDetector: auto_config: false method_type: new_value_detector params: log_variables: - id: test template: dummy_template variables: - name: var1 pos: 0 params: threshold: 0.8 The service supports dynamic reconfiguration with two modes:","title":"4. Reconfigure at runtime"},{"location":"library/#1-in-memory-update-default","text":"Changes are applied to the running service but not saved to disk. The changes will be lost when the service restarts. detectmate-client --url 127.0.0.1:8000 reconfigure path/to/new-config.yaml","title":"1. In-memory update (default)"},{"location":"library/#2-persistent-update-with-persist-flag","text":"Changes are applied to the running service AND saved to the original parameter file. The changes persist across service restarts. detectmate-client --url 127.0.0.1:8000 reconfigure path/to/new-config.yaml --persist Note: The --persist flag will overwrite the original parameter file specified in your service configuration with the new values.","title":"2. Persistent update (with --persist flag)"},{"location":"pipeline/","text":"Running the Docker Pipeline There is a containerized demonstration of the DetectMate log analysis pipeline. The demo runs three services (reader, parser, detector) that process audit logs to detect anomalies, with a test script that feeds log lines through the complete pipeline and reports detected anomalies. Each component runs in its own Docker container and the components communicate via TCP. This document explains how to run the example pipeline using Docker, located in the demo folder. Components The pipeline consists of the following services defined in demo/docker-compose.yml : Reader ( detectmate_reader ) : reads log lines from a source file ( demo/data/audit.log ) uses demo/config/reader_config.yaml listens on internal port 8001 Parser ( detectmate_parser ) : receives raw log data, parses it into a structured format uses demo/config/parser_config.yaml listens on internal port 8011 depends on the Reader Detector ( detectmate_detector ) : analyzes structured logs to detect anomalies uses demo/config/detector_config.yaml listens on internal port 8021 depends on the Parser Demo Driver ( detectmate_demo ) : Acts as the orchestrator/client. It executes the demo/manual_demo_run_tcp.py script. It does the following: count lines in the audit log for each line, it sends a request to the Reader to get a log line forwards the log line to the Parser for processing forwards the parsed data to the Detector for analysis prints any detected anomalies to the console How to Run Prerequisites: Docker and Docker Compose installed. Terminal 1 (keep running to see service logs): cd demo docker compose up reader parser detector Terminal 2 (run after services are up): cd demo docker compose up demo Directory Structure demo/Dockerfile : The Docker definition used by all services. demo/docker-compose.yml : Defines the multi-container application. demo/config/ : Contains YAML configuration files for Reader, Parser, and Detector. demo/data/ : Contains sample data (e.g., audit.log ) used by the Reader. demo/manual_demo_run_tcp.py : The Python script running inside the demo container that drives the flow.","title":"Running a Pipeline"},{"location":"pipeline/#running-the-docker-pipeline","text":"There is a containerized demonstration of the DetectMate log analysis pipeline. The demo runs three services (reader, parser, detector) that process audit logs to detect anomalies, with a test script that feeds log lines through the complete pipeline and reports detected anomalies. Each component runs in its own Docker container and the components communicate via TCP. This document explains how to run the example pipeline using Docker, located in the demo folder.","title":"Running the Docker Pipeline"},{"location":"pipeline/#components","text":"The pipeline consists of the following services defined in demo/docker-compose.yml : Reader ( detectmate_reader ) : reads log lines from a source file ( demo/data/audit.log ) uses demo/config/reader_config.yaml listens on internal port 8001 Parser ( detectmate_parser ) : receives raw log data, parses it into a structured format uses demo/config/parser_config.yaml listens on internal port 8011 depends on the Reader Detector ( detectmate_detector ) : analyzes structured logs to detect anomalies uses demo/config/detector_config.yaml listens on internal port 8021 depends on the Parser Demo Driver ( detectmate_demo ) : Acts as the orchestrator/client. It executes the demo/manual_demo_run_tcp.py script. It does the following: count lines in the audit log for each line, it sends a request to the Reader to get a log line forwards the log line to the Parser for processing forwards the parsed data to the Detector for analysis prints any detected anomalies to the console","title":"Components"},{"location":"pipeline/#how-to-run","text":"Prerequisites: Docker and Docker Compose installed. Terminal 1 (keep running to see service logs): cd demo docker compose up reader parser detector Terminal 2 (run after services are up): cd demo docker compose up demo","title":"How to Run"},{"location":"pipeline/#directory-structure","text":"demo/Dockerfile : The Docker definition used by all services. demo/docker-compose.yml : Defines the multi-container application. demo/config/ : Contains YAML configuration files for Reader, Parser, and Detector. demo/data/ : Contains sample data (e.g., audit.log ) used by the Reader. demo/manual_demo_run_tcp.py : The Python script running inside the demo container that drives the flow.","title":"Directory Structure"},{"location":"usage/","text":"Usage DetectMateService provides a command-line interface (CLI) detectmate to manage the service. Quick start your first Service To run a component with default settings only, you can use this command: detectmate You should see output like: [2026-01-20 15:16:21,140] INFO service.cli: config file: None [2026-01-20 15:16:21,140] INFO service.cli: config file: None [2026-01-20 15:16:21,143] INFO core.5958cc49c05e572baa4f0acbc4b33f87: No output addresses configured, processed messages will not be forwarded [2026-01-20 15:16:21,143] INFO core.5958cc49c05e572baa4f0acbc4b33f87: engine started [2026-01-20 15:16:21,143] INFO core.5958cc49c05e572baa4f0acbc4b33f87: setup_io: ready to process messages [2026-01-20 15:16:21,143] INFO core.5958cc49c05e572baa4f0acbc4b33f87: HTTP Admin active at 127.0.0.1:8000 [2026-01-20 15:16:21,143] INFO core.5958cc49c05e572baa4f0acbc4b33f87: Auto-starting engine... INFO: Started server process [3933168] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) Create service settings To run the service with custom variables, we can define settings. For example, create a file named settings.yaml : component_name: my-first-service component_type: core # or use a library component like \"detectors.RandomDetector\" log_level: INFO log_dir: ./logs http_host: 127.0.0.1 http_port: 8000 engine_addr: ipc:///tmp/detectmate.engine.ipc Start the service with settings To start the service, use the detectmate command. You can optionally specify a settings file and a component configuration file. detectmate --settings settings.yaml --config config.yaml --settings : Path to the service settings YAML file. --config : Path to the component configuration YAML file. Checking status To check the status of a running service run: detectmate-client status --url <http_host:http_port> Output: { \"status\": { \"component_type\": \"core\", \"component_id\": \"abc123...\", \"running\": true }, \"settings\": { \"component_name\": \"my-first-service\", \"log_level\": \"INFO\", ... }, \"configs\": {} } Reconfiguring You can update the component configuration of a running service without restarting it: detectmate-client --url <http_host:http_port> reconfigure new_config.yaml Add --persist to save the new configuration to the original config file (if supported). detectmate --url <http_host:http_port> reconfigure new_config.yaml --persist Stopping the service To stop the service: detectmate stop --url <http_host:http_port>","title":"Quick Start"},{"location":"usage/#usage","text":"DetectMateService provides a command-line interface (CLI) detectmate to manage the service.","title":"Usage"},{"location":"usage/#quick-start-your-first-service","text":"To run a component with default settings only, you can use this command: detectmate You should see output like: [2026-01-20 15:16:21,140] INFO service.cli: config file: None [2026-01-20 15:16:21,140] INFO service.cli: config file: None [2026-01-20 15:16:21,143] INFO core.5958cc49c05e572baa4f0acbc4b33f87: No output addresses configured, processed messages will not be forwarded [2026-01-20 15:16:21,143] INFO core.5958cc49c05e572baa4f0acbc4b33f87: engine started [2026-01-20 15:16:21,143] INFO core.5958cc49c05e572baa4f0acbc4b33f87: setup_io: ready to process messages [2026-01-20 15:16:21,143] INFO core.5958cc49c05e572baa4f0acbc4b33f87: HTTP Admin active at 127.0.0.1:8000 [2026-01-20 15:16:21,143] INFO core.5958cc49c05e572baa4f0acbc4b33f87: Auto-starting engine... INFO: Started server process [3933168] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)","title":"Quick start your first Service"},{"location":"usage/#create-service-settings","text":"To run the service with custom variables, we can define settings. For example, create a file named settings.yaml : component_name: my-first-service component_type: core # or use a library component like \"detectors.RandomDetector\" log_level: INFO log_dir: ./logs http_host: 127.0.0.1 http_port: 8000 engine_addr: ipc:///tmp/detectmate.engine.ipc","title":"Create service settings"},{"location":"usage/#start-the-service-with-settings","text":"To start the service, use the detectmate command. You can optionally specify a settings file and a component configuration file. detectmate --settings settings.yaml --config config.yaml --settings : Path to the service settings YAML file. --config : Path to the component configuration YAML file.","title":"Start the service with settings"},{"location":"usage/#checking-status","text":"To check the status of a running service run: detectmate-client status --url <http_host:http_port> Output: { \"status\": { \"component_type\": \"core\", \"component_id\": \"abc123...\", \"running\": true }, \"settings\": { \"component_name\": \"my-first-service\", \"log_level\": \"INFO\", ... }, \"configs\": {} }","title":"Checking status"},{"location":"usage/#reconfiguring","text":"You can update the component configuration of a running service without restarting it: detectmate-client --url <http_host:http_port> reconfigure new_config.yaml Add --persist to save the new configuration to the original config file (if supported). detectmate --url <http_host:http_port> reconfigure new_config.yaml --persist","title":"Reconfiguring"},{"location":"usage/#stopping-the-service","text":"To stop the service: detectmate stop --url <http_host:http_port>","title":"Stopping the service"}]}